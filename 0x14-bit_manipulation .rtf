{\rtf1\ansi\ansicpg1252\cocoartf2708
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww28600\viewh17440\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 0x14-bit_manipulation\
\
\
\
Main.h\
\
#ifndef MAIN_H\
#define MAIN_H\
\
unsigned int binary_to_uint(const char *b);\
void print_binary(unsigned long int n);\
int get_bit(unsigned long int n, unsigned int index);\
int set_bit(unsigned long int *n, unsigned int index);\
int clear_bit(unsigned long int *n, unsigned int index);\
unsigned int flip_bits(unsigned long int n, unsigned long int m);\
int _atoi(const char *s);\
int _putchar(char c);\
int get_endianness(void);\
\
#endif\
\
\
\
0 binary\
\
#include "main.h"\
\
/**\
 * binary_to_uint - converting binary number to unsigned int\
\'a0* @b: string containing binary number\
\'a0*\
\'a0* Return: converted number\
*/\
\
unsigned int binary_to_uint(const char *b)\
\{\
	int x;\
	unsigned int dec_val = 0;\
\
	if (!b)\
		return (0);\
\
	for (x = 0; b[x]; x++)\
	\{\
		if (b[x] < '0' || b[x] > '1')\
			return (0);\
		dec_val = 2 * dec_val + (b[x] - '0');\
	\}\
\
	return (dec_val);\
\}\
\
\
1 print binary\
\
#include "main.h"\
\
/**\
 * print_binary - printing binary representation of a decimal number\
\'a0* @n: number to print in binary\
*/\
\
void print_binary(unsigned long int n)\
\{\
	int x count = 0;\
	unsigned long int current;\
\
	for (x = 63; x >= 0; x--)\
	\{\
		current = n >> x;\
\
		if (current & 1)\
		\{\
			_putchar('1');\
			count++;\
		\}\
		else if (count)\
			_putchar('0');\
	\}\
	if (!count)\
		_putchar('0');\
\}\
\
\
2 get bit\
\
#include "main.h"\
\
/**\
 *get_bit - return value of given index\
\'a0* @n: number to search\
\'a0* @index: index of the bit to get\
\'a0*\
\'a0* Return: value of the bit\
*/\
\
int get_bit(unsigned long int n, unsigned int index)\
\{\
	int bit_val;\
\
	if (index > 63)\
		return (-1);\
\
	bit_val = (n >> index) & 1;\
\
	return (bit_val);\
\}\
\
\
3 set bit\
\
#include "main.h"\
\
/**\
 * set_bit - setting value of a bit at a given index to 1\
\'a0* @n: pointer to number to change\
\'a0* @index: index of the bit to set to 1\
\'a0*\
\'a0* Return: 1 for success, -1 for failure\
*/\
\
int set_bit(unsigned long int *n, unsigned int index)\
\{\
	if (index > 63)\
		return (-1);\
\
	*n = ((1UL << index) | *n);\
	return (1);\
\}\
\
\
4 Clear bit\
\
#include "main.h"\
\
/**\
 * clear_bit - setting value of a given bit to 0\
\'a0* @n: pointer to number to change\
\'a0* @index: index of the bit to clear\
\'a0*\
\'a0* Return: 1 for success, -1 for failure\
*/\
\
int clear_bit(unsigned long int *n, unsigned int index)\
\{\
	if (index > 63)\
		return (-1);\
\
	*n = (~(1UL << index) & *n);\
	return (1);\
\}\
\
\
5 flip bits\
\
#include "main.h"\
\
/**\
 * flip_bits - counting number of bits to flip\
\'a0* @n: first number\
\'a0* @m: second number\
\'a0*\
\'a0* Return: number of bits to change\
*/\
\
unsigned int flip_bits(unsigned long int n, unsigned long int m)\
\{\
	int x, count = 0;\
	unsigned long int current;\
	unsigned long int exclusive = n ^ m;\
\
	for (x = 63; x >= 0; x--)\
	\{\
		current = exclusive >> x;\
		if (current & 1)\
			count++;\
	\}\
\
	return (count);\
\}\
\
\
Putchar \
\
#include "main.h"\
#include <unistd.h>\
\
/**\
 * _putchar - writes the character c to stdout\
\'a0* @c: The character to print\
\'a0*\
\'a0* Return: On success 1.\
\'a0* On error, -1 is returned, and errno is set appropriately\
*/\
\
int _putchar(char c)\
\{\
	return (write(1, &c, 1));\
\}\
\
\
0x14-bit_manipulation/100-get_endianness.c\
\
#include "main.h"\
\
/**\
 * get_endianness - checking if a machine is endianness\
\'a0* Return: 0 if big endian, 1 if little endian\
*/\
\
int get_endianness(void)\
\{\
	unsigned int x = 1;\
	char *c = (char *) &x;\
\
	return (*c);\
\}\
\
0x14-bit_manipulation/101-password\
\
\
None\
\
\
\
}